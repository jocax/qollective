# [doc = r" Error types."] pub mod error { # [doc = r" Error from a `TryFrom` or `FromStr` implementation."] pub struct ConversionError (:: std :: borrow :: Cow < 'static , str >) ; impl :: std :: error :: Error for ConversionError { } impl :: std :: fmt :: Display for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Display :: fmt (& self . 0 , f) } } impl :: std :: fmt :: Debug for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Debug :: fmt (& self . 0 , f) } } impl From < & 'static str > for ConversionError { fn from (value : & 'static str) -> Self { Self (value . into ()) } } impl From < String > for ConversionError { fn from (value : String) -> Self { Self (value . into ()) } } } # [doc = "`Item`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"id\","] # [doc = "    \"status\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"id\": {"] # [doc = "      \"description\": \"Unique identifier\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"metadata\": {"] # [doc = "      \"$ref\": \"#/$defs/Metadata\""] # [doc = "    },"] # [doc = "    \"status\": {"] # [doc = "      \"$ref\": \"#/$defs/Status\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] pub struct Item { # [doc = "Unique identifier"] pub id : :: uuid :: Uuid , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub metadata : :: std :: option :: Option < Metadata > , pub status : Status , } impl :: std :: convert :: From < & Item > for Item { fn from (value : & Item) -> Self { value . clone () } } impl Item { pub fn builder () -> builder :: Item { Default :: default () } } # [doc = "`Metadata`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"created\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"created\": {"] # [doc = "      \"description\": \"Creation timestamp\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"updated\": {"] # [doc = "      \"description\": \"Last update timestamp\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] pub struct Metadata { # [doc = "Creation timestamp"] pub created : :: chrono :: DateTime < :: chrono :: offset :: Utc > , # [doc = "Last update timestamp"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub updated : :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , } impl :: std :: convert :: From < & Metadata > for Metadata { fn from (value : & Metadata) -> Self { value . clone () } } impl Metadata { pub fn builder () -> builder :: Metadata { Default :: default () } } # [doc = "Tests $ref resolution and nested type dependencies"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://schemas.qollective.io/test/nested-types/v1.0.0\","] # [doc = "  \"title\": \"Nested Types Test Schema\","] # [doc = "  \"description\": \"Tests $ref resolution and nested type dependencies\","] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"#/$defs/Item\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"$ref\": \"#/$defs/Metadata\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"$ref\": \"#/$defs/Status\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] # [serde (untagged)] pub enum NestedTypesTestSchema { Item (Item) , Metadata (Metadata) , Status (Status) , } impl :: std :: convert :: From < & Self > for NestedTypesTestSchema { fn from (value : & NestedTypesTestSchema) -> Self { value . clone () } } impl :: std :: convert :: From < Item > for NestedTypesTestSchema { fn from (value : Item) -> Self { Self :: Item (value) } } impl :: std :: convert :: From < Metadata > for NestedTypesTestSchema { fn from (value : Metadata) -> Self { Self :: Metadata (value) } } impl :: std :: convert :: From < Status > for NestedTypesTestSchema { fn from (value : Status) -> Self { Self :: Status (value) } } # [doc = "Publication status"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Publication status\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"draft\","] # [doc = "    \"published\","] # [doc = "    \"archived\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum Status { # [serde (rename = "draft")] Draft , # [serde (rename = "published")] Published , # [serde (rename = "archived")] Archived , } impl :: std :: convert :: From < & Self > for Status { fn from (value : & Status) -> Self { value . clone () } } impl :: std :: fmt :: Display for Status { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Draft => write ! (f , "draft") , Self :: Published => write ! (f , "published") , Self :: Archived => write ! (f , "archived") , } } } impl :: std :: str :: FromStr for Status { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "draft" => Ok (Self :: Draft) , "published" => Ok (Self :: Published) , "archived" => Ok (Self :: Archived) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for Status { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for Status { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for Status { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = r" Types for composing complex structures."] pub mod builder { # [derive (Clone , Debug)] pub struct Item { id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , metadata : :: std :: result :: Result < :: std :: option :: Option < super :: Metadata > , :: std :: string :: String > , status : :: std :: result :: Result < super :: Status , :: std :: string :: String > , } impl :: std :: default :: Default for Item { fn default () -> Self { Self { id : Err ("no value supplied for id" . to_string ()) , metadata : Ok (Default :: default ()) , status : Err ("no value supplied for status" . to_string ()) , } } } impl Item { pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn metadata < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < super :: Metadata > > , T :: Error : :: std :: fmt :: Display , { self . metadata = value . try_into () . map_err (| e | format ! ("error converting supplied value for metadata: {}" , e)) ; self } pub fn status < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: Status > , T :: Error : :: std :: fmt :: Display , { self . status = value . try_into () . map_err (| e | format ! ("error converting supplied value for status: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Item > for super :: Item { type Error = super :: error :: ConversionError ; fn try_from (value : Item) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { id : value . id ? , metadata : value . metadata ? , status : value . status ? , }) } } impl :: std :: convert :: From < super :: Item > for Item { fn from (value : super :: Item) -> Self { Self { id : Ok (value . id) , metadata : Ok (value . metadata) , status : Ok (value . status) , } } } # [derive (Clone , Debug)] pub struct Metadata { created : :: std :: result :: Result < :: chrono :: DateTime < :: chrono :: offset :: Utc > , :: std :: string :: String > , updated : :: std :: result :: Result < :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , :: std :: string :: String > , } impl :: std :: default :: Default for Metadata { fn default () -> Self { Self { created : Err ("no value supplied for created" . to_string ()) , updated : Ok (Default :: default ()) , } } } impl Metadata { pub fn created < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: chrono :: DateTime < :: chrono :: offset :: Utc > > , T :: Error : :: std :: fmt :: Display , { self . created = value . try_into () . map_err (| e | format ! ("error converting supplied value for created: {}" , e)) ; self } pub fn updated < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: chrono :: DateTime < :: chrono :: offset :: Utc > > > , T :: Error : :: std :: fmt :: Display , { self . updated = value . try_into () . map_err (| e | format ! ("error converting supplied value for updated: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Metadata > for super :: Metadata { type Error = super :: error :: ConversionError ; fn try_from (value : Metadata) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { created : value . created ? , updated : value . updated ? , }) } } impl :: std :: convert :: From < super :: Metadata > for Metadata { fn from (value : super :: Metadata) -> Self { Self { created : Ok (value . created) , updated : Ok (value . updated) , } } } }