# [doc = r" Error types."] pub mod error { # [doc = r" Error from a `TryFrom` or `FromStr` implementation."] pub struct ConversionError (:: std :: borrow :: Cow < 'static , str >) ; impl :: std :: error :: Error for ConversionError { } impl :: std :: fmt :: Display for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Display :: fmt (& self . 0 , f) } } impl :: std :: fmt :: Debug for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Debug :: fmt (& self . 0 , f) } } impl From < & 'static str > for ConversionError { fn from (value : & 'static str) -> Self { Self (value . into ()) } } impl From < String > for ConversionError { fn from (value : String) -> Self { Self (value . into ()) } } } # [doc = "Tests integer type selection based on min/max constraints"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://schemas.qollective.io/test/numeric-validation/v1.0.0\","] # [doc = "  \"title\": \"Numeric Validation Test Schema\","] # [doc = "  \"description\": \"Tests integer type selection based on min/max constraints\","] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"#/$defs/Percentage\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"$ref\": \"#/$defs/Port\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"$ref\": \"#/$defs/SmallCount\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"$ref\": \"#/$defs/Temperature\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] # [serde (untagged)] pub enum NumericValidationTestSchema { Percentage (Percentage) , Port (Port) , SmallCount (SmallCount) , Temperature (Temperature) , } impl :: std :: convert :: From < & Self > for NumericValidationTestSchema { fn from (value : & NumericValidationTestSchema) -> Self { value . clone () } } impl :: std :: convert :: From < Percentage > for NumericValidationTestSchema { fn from (value : Percentage) -> Self { Self :: Percentage (value) } } impl :: std :: convert :: From < Port > for NumericValidationTestSchema { fn from (value : Port) -> Self { Self :: Port (value) } } impl :: std :: convert :: From < SmallCount > for NumericValidationTestSchema { fn from (value : SmallCount) -> Self { Self :: SmallCount (value) } } impl :: std :: convert :: From < Temperature > for NumericValidationTestSchema { fn from (value : Temperature) -> Self { Self :: Temperature (value) } } # [doc = "`Percentage`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"value\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"value\": {"] # [doc = "      \"description\": \"Percentage value (0-100), should generate u8\","] # [doc = "      \"type\": \"integer\","] # [doc = "      \"maximum\": 100.0,"] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] pub struct Percentage { # [doc = "Percentage value (0-100), should generate u8"] pub value : i64 , } impl :: std :: convert :: From < & Percentage > for Percentage { fn from (value : & Percentage) -> Self { value . clone () } } impl Percentage { pub fn builder () -> builder :: Percentage { Default :: default () } } # [doc = "`Port`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"number\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"number\": {"] # [doc = "      \"description\": \"Network port number (0-65535), should generate u16\","] # [doc = "      \"type\": \"integer\","] # [doc = "      \"maximum\": 65535.0,"] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] pub struct Port { # [doc = "Network port number (0-65535), should generate u16"] pub number : u16 , } impl :: std :: convert :: From < & Port > for Port { fn from (value : & Port) -> Self { value . clone () } } impl Port { pub fn builder () -> builder :: Port { Default :: default () } } # [doc = "`SmallCount`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"count\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"count\": {"] # [doc = "      \"description\": \"Small count (1-255), should generate u8\","] # [doc = "      \"type\": \"integer\","] # [doc = "      \"maximum\": 255.0,"] # [doc = "      \"minimum\": 1.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] pub struct SmallCount { # [doc = "Small count (1-255), should generate u8"] pub count : :: std :: num :: NonZeroU64 , } impl :: std :: convert :: From < & SmallCount > for SmallCount { fn from (value : & SmallCount) -> Self { value . clone () } } impl SmallCount { pub fn builder () -> builder :: SmallCount { Default :: default () } } # [doc = "`Temperature`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"celsius\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"celsius\": {"] # [doc = "      \"description\": \"Temperature in Celsius (-273 to 5778), should generate i16\","] # [doc = "      \"type\": \"integer\","] # [doc = "      \"maximum\": 5778.0,"] # [doc = "      \"minimum\": -273.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] pub struct Temperature { # [doc = "Temperature in Celsius (-273 to 5778), should generate i16"] pub celsius : i64 , } impl :: std :: convert :: From < & Temperature > for Temperature { fn from (value : & Temperature) -> Self { value . clone () } } impl Temperature { pub fn builder () -> builder :: Temperature { Default :: default () } } # [doc = r" Types for composing complex structures."] pub mod builder { # [derive (Clone , Debug)] pub struct Percentage { value : :: std :: result :: Result < i64 , :: std :: string :: String > , } impl :: std :: default :: Default for Percentage { fn default () -> Self { Self { value : Err ("no value supplied for value" . to_string ()) , } } } impl Percentage { pub fn value < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < i64 > , T :: Error : :: std :: fmt :: Display , { self . value = value . try_into () . map_err (| e | format ! ("error converting supplied value for value: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Percentage > for super :: Percentage { type Error = super :: error :: ConversionError ; fn try_from (value : Percentage) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { value : value . value ? , }) } } impl :: std :: convert :: From < super :: Percentage > for Percentage { fn from (value : super :: Percentage) -> Self { Self { value : Ok (value . value) , } } } # [derive (Clone , Debug)] pub struct Port { number : :: std :: result :: Result < u16 , :: std :: string :: String > , } impl :: std :: default :: Default for Port { fn default () -> Self { Self { number : Err ("no value supplied for number" . to_string ()) , } } } impl Port { pub fn number < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < u16 > , T :: Error : :: std :: fmt :: Display , { self . number = value . try_into () . map_err (| e | format ! ("error converting supplied value for number: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Port > for super :: Port { type Error = super :: error :: ConversionError ; fn try_from (value : Port) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { number : value . number ? , }) } } impl :: std :: convert :: From < super :: Port > for Port { fn from (value : super :: Port) -> Self { Self { number : Ok (value . number) , } } } # [derive (Clone , Debug)] pub struct SmallCount { count : :: std :: result :: Result < :: std :: num :: NonZeroU64 , :: std :: string :: String > , } impl :: std :: default :: Default for SmallCount { fn default () -> Self { Self { count : Err ("no value supplied for count" . to_string ()) , } } } impl SmallCount { pub fn count < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: num :: NonZeroU64 > , T :: Error : :: std :: fmt :: Display , { self . count = value . try_into () . map_err (| e | format ! ("error converting supplied value for count: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < SmallCount > for super :: SmallCount { type Error = super :: error :: ConversionError ; fn try_from (value : SmallCount) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { count : value . count ? , }) } } impl :: std :: convert :: From < super :: SmallCount > for SmallCount { fn from (value : super :: SmallCount) -> Self { Self { count : Ok (value . count) , } } } # [derive (Clone , Debug)] pub struct Temperature { celsius : :: std :: result :: Result < i64 , :: std :: string :: String > , } impl :: std :: default :: Default for Temperature { fn default () -> Self { Self { celsius : Err ("no value supplied for celsius" . to_string ()) , } } } impl Temperature { pub fn celsius < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < i64 > , T :: Error : :: std :: fmt :: Display , { self . celsius = value . try_into () . map_err (| e | format ! ("error converting supplied value for celsius: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Temperature > for super :: Temperature { type Error = super :: error :: ConversionError ; fn try_from (value : Temperature) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { celsius : value . celsius ? , }) } } impl :: std :: convert :: From < super :: Temperature > for Temperature { fn from (value : super :: Temperature) -> Self { Self { celsius : Ok (value . celsius) , } } } }