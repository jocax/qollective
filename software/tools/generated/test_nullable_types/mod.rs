# [doc = r" Error types."] pub mod error { # [doc = r" Error from a `TryFrom` or `FromStr` implementation."] pub struct ConversionError (:: std :: borrow :: Cow < 'static , str >) ; impl :: std :: error :: Error for ConversionError { } impl :: std :: fmt :: Display for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Display :: fmt (& self . 0 , f) } } impl :: std :: fmt :: Debug for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Debug :: fmt (& self . 0 , f) } } impl From < & 'static str > for ConversionError { fn from (value : & 'static str) -> Self { Self (value . into ()) } } impl From < String > for ConversionError { fn from (value : String) -> Self { Self (value . into ()) } } } # [doc = "`Item`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"id\","] # [doc = "    \"name\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"counts\": {"] # [doc = "      \"$ref\": \"#/$defs/OptionalCounts\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"uuid\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 255,"] # [doc = "      \"minLength\": 1"] # [doc = "    },"] # [doc = "    \"price\": {"] # [doc = "      \"$ref\": \"#/$defs/Price\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] pub struct Item { # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub counts : :: std :: option :: Option < OptionalCounts > , pub id : :: uuid :: Uuid , pub name : ItemName , # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub price : :: std :: option :: Option < Price > , } impl :: std :: convert :: From < & Item > for Item { fn from (value : & Item) -> Self { value . clone () } } impl Item { pub fn builder () -> builder :: Item { Default :: default () } } # [doc = "`ItemName`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 255,"] # [doc = "  \"minLength\": 1"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] # [serde (transparent)] pub struct ItemName (:: std :: string :: String) ; impl :: std :: ops :: Deref for ItemName { type Target = :: std :: string :: String ; fn deref (& self) -> & :: std :: string :: String { & self . 0 } } impl :: std :: convert :: From < ItemName > for :: std :: string :: String { fn from (value : ItemName) -> Self { value . 0 } } impl :: std :: convert :: From < & ItemName > for ItemName { fn from (value : & ItemName) -> Self { value . clone () } } impl :: std :: str :: FromStr for ItemName { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { if value . chars () . count () > 255usize { return Err ("longer than 255 characters" . into ()) ; } if value . chars () . count () < 1usize { return Err ("shorter than 1 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for ItemName { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for ItemName { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for ItemName { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for ItemName { fn deserialize < D > (deserializer : D ,) -> :: std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { :: std :: string :: String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = "Tests nullable type handling with explicit null"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"$id\": \"https://schemas.qollective.io/test/nullable-types/v1.0.0\","] # [doc = "  \"title\": \"Nullable Types Test Schema\","] # [doc = "  \"description\": \"Tests nullable type handling with explicit null\","] # [doc = "  \"oneOf\": ["] # [doc = "    {"] # [doc = "      \"$ref\": \"#/$defs/Item\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"$ref\": \"#/$defs/OptionalCounts\""] # [doc = "    },"] # [doc = "    {"] # [doc = "      \"$ref\": \"#/$defs/Price\""] # [doc = "    }"] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] # [serde (untagged)] pub enum NullableTypesTestSchema { Item (Item) , OptionalCounts (OptionalCounts) , Price (Price) , } impl :: std :: convert :: From < & Self > for NullableTypesTestSchema { fn from (value : & NullableTypesTestSchema) -> Self { value . clone () } } impl :: std :: convert :: From < Item > for NullableTypesTestSchema { fn from (value : Item) -> Self { Self :: Item (value) } } impl :: std :: convert :: From < OptionalCounts > for NullableTypesTestSchema { fn from (value : OptionalCounts) -> Self { Self :: OptionalCounts (value) } } impl :: std :: convert :: From < Price > for NullableTypesTestSchema { fn from (value : Price) -> Self { Self :: Price (value) } } # [doc = "`OptionalCounts`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"properties\": {"] # [doc = "    \"likes\": {"] # [doc = "      \"description\": \"Like count (null if not tracked)\","] # [doc = "      \"type\": ["] # [doc = "        \"integer\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"views\": {"] # [doc = "      \"description\": \"View count (null if not tracked)\","] # [doc = "      \"type\": ["] # [doc = "        \"integer\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] pub struct OptionalCounts { # [doc = "Like count (null if not tracked)"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub likes : :: std :: option :: Option < u64 > , # [doc = "View count (null if not tracked)"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub views : :: std :: option :: Option < u64 > , } impl :: std :: convert :: From < & OptionalCounts > for OptionalCounts { fn from (value : & OptionalCounts) -> Self { value . clone () } } impl :: std :: default :: Default for OptionalCounts { fn default () -> Self { Self { likes : Default :: default () , views : Default :: default () , } } } impl OptionalCounts { pub fn builder () -> builder :: OptionalCounts { Default :: default () } } # [doc = "`Price`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"currency\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"amount\": {"] # [doc = "      \"description\": \"Price amount (null for free)\","] # [doc = "      \"type\": ["] # [doc = "        \"number\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"minimum\": 0.0"] # [doc = "    },"] # [doc = "    \"currency\": {"] # [doc = "      \"description\": \"Currency code (ISO 4217)\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"maxLength\": 3,"] # [doc = "      \"minLength\": 3"] # [doc = "    },"] # [doc = "    \"discount\": {"] # [doc = "      \"description\": \"Discount percentage (null for no discount)\","] # [doc = "      \"type\": ["] # [doc = "        \"number\","] # [doc = "        \"null\""] # [doc = "      ],"] # [doc = "      \"maximum\": 1.0,"] # [doc = "      \"minimum\": 0.0"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug , PartialEq)] pub struct Price { # [doc = "Price amount (null for free)"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub amount : :: std :: option :: Option < f64 > , # [doc = "Currency code (ISO 4217)"] pub currency : PriceCurrency , # [doc = "Discount percentage (null for no discount)"] # [serde (default , skip_serializing_if = "::std::option::Option::is_none")] pub discount : :: std :: option :: Option < f64 > , } impl :: std :: convert :: From < & Price > for Price { fn from (value : & Price) -> Self { value . clone () } } impl Price { pub fn builder () -> builder :: Price { Default :: default () } } # [doc = "Currency code (ISO 4217)"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Currency code (ISO 4217)\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"maxLength\": 3,"] # [doc = "  \"minLength\": 3"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Serialize , Clone , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] # [serde (transparent)] pub struct PriceCurrency (:: std :: string :: String) ; impl :: std :: ops :: Deref for PriceCurrency { type Target = :: std :: string :: String ; fn deref (& self) -> & :: std :: string :: String { & self . 0 } } impl :: std :: convert :: From < PriceCurrency > for :: std :: string :: String { fn from (value : PriceCurrency) -> Self { value . 0 } } impl :: std :: convert :: From < & PriceCurrency > for PriceCurrency { fn from (value : & PriceCurrency) -> Self { value . clone () } } impl :: std :: str :: FromStr for PriceCurrency { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { if value . chars () . count () > 3usize { return Err ("longer than 3 characters" . into ()) ; } if value . chars () . count () < 3usize { return Err ("shorter than 3 characters" . into ()) ; } Ok (Self (value . to_string ())) } } impl :: std :: convert :: TryFrom < & str > for PriceCurrency { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for PriceCurrency { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for PriceCurrency { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl < 'de > :: serde :: Deserialize < 'de > for PriceCurrency { fn deserialize < D > (deserializer : D ,) -> :: std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { :: std :: string :: String :: deserialize (deserializer) ? . parse () . map_err (| e : self :: error :: ConversionError | { < D :: Error as :: serde :: de :: Error > :: custom (e . to_string () ,) }) } } # [doc = r" Types for composing complex structures."] pub mod builder { # [derive (Clone , Debug)] pub struct Item { counts : :: std :: result :: Result < :: std :: option :: Option < super :: OptionalCounts > , :: std :: string :: String > , id : :: std :: result :: Result < :: uuid :: Uuid , :: std :: string :: String > , name : :: std :: result :: Result < super :: ItemName , :: std :: string :: String > , price : :: std :: result :: Result < :: std :: option :: Option < super :: Price > , :: std :: string :: String > , } impl :: std :: default :: Default for Item { fn default () -> Self { Self { counts : Ok (Default :: default ()) , id : Err ("no value supplied for id" . to_string ()) , name : Err ("no value supplied for name" . to_string ()) , price : Ok (Default :: default ()) , } } } impl Item { pub fn counts < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < super :: OptionalCounts > > , T :: Error : :: std :: fmt :: Display , { self . counts = value . try_into () . map_err (| e | format ! ("error converting supplied value for counts: {}" , e)) ; self } pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: uuid :: Uuid > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: ItemName > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } pub fn price < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < super :: Price > > , T :: Error : :: std :: fmt :: Display , { self . price = value . try_into () . map_err (| e | format ! ("error converting supplied value for price: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Item > for super :: Item { type Error = super :: error :: ConversionError ; fn try_from (value : Item) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { counts : value . counts ? , id : value . id ? , name : value . name ? , price : value . price ? , }) } } impl :: std :: convert :: From < super :: Item > for Item { fn from (value : super :: Item) -> Self { Self { counts : Ok (value . counts) , id : Ok (value . id) , name : Ok (value . name) , price : Ok (value . price) , } } } # [derive (Clone , Debug)] pub struct OptionalCounts { likes : :: std :: result :: Result < :: std :: option :: Option < u64 > , :: std :: string :: String > , views : :: std :: result :: Result < :: std :: option :: Option < u64 > , :: std :: string :: String > , } impl :: std :: default :: Default for OptionalCounts { fn default () -> Self { Self { likes : Ok (Default :: default ()) , views : Ok (Default :: default ()) , } } } impl OptionalCounts { pub fn likes < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < u64 > > , T :: Error : :: std :: fmt :: Display , { self . likes = value . try_into () . map_err (| e | format ! ("error converting supplied value for likes: {}" , e)) ; self } pub fn views < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < u64 > > , T :: Error : :: std :: fmt :: Display , { self . views = value . try_into () . map_err (| e | format ! ("error converting supplied value for views: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < OptionalCounts > for super :: OptionalCounts { type Error = super :: error :: ConversionError ; fn try_from (value : OptionalCounts) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { likes : value . likes ? , views : value . views ? , }) } } impl :: std :: convert :: From < super :: OptionalCounts > for OptionalCounts { fn from (value : super :: OptionalCounts) -> Self { Self { likes : Ok (value . likes) , views : Ok (value . views) , } } } # [derive (Clone , Debug)] pub struct Price { amount : :: std :: result :: Result < :: std :: option :: Option < f64 > , :: std :: string :: String > , currency : :: std :: result :: Result < super :: PriceCurrency , :: std :: string :: String > , discount : :: std :: result :: Result < :: std :: option :: Option < f64 > , :: std :: string :: String > , } impl :: std :: default :: Default for Price { fn default () -> Self { Self { amount : Ok (Default :: default ()) , currency : Err ("no value supplied for currency" . to_string ()) , discount : Ok (Default :: default ()) , } } } impl Price { pub fn amount < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < f64 > > , T :: Error : :: std :: fmt :: Display , { self . amount = value . try_into () . map_err (| e | format ! ("error converting supplied value for amount: {}" , e)) ; self } pub fn currency < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: PriceCurrency > , T :: Error : :: std :: fmt :: Display , { self . currency = value . try_into () . map_err (| e | format ! ("error converting supplied value for currency: {}" , e)) ; self } pub fn discount < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < f64 > > , T :: Error : :: std :: fmt :: Display , { self . discount = value . try_into () . map_err (| e | format ! ("error converting supplied value for discount: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < Price > for super :: Price { type Error = super :: error :: ConversionError ; fn try_from (value : Price) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { amount : value . amount ? , currency : value . currency ? , discount : value . discount ? , }) } } impl :: std :: convert :: From < super :: Price > for Price { fn from (value : super :: Price) -> Self { Self { amount : Ok (value . amount) , currency : Ok (value . currency) , discount : Ok (value . discount) , } } } }