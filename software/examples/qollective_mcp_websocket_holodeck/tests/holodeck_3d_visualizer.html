<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qollective Holodeck 3D Environment Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            color: #00ff41;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            border-radius: 10px;
            padding: 20px;
            max-width: 400px;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #info-panel h1 {
            color: #00ff41;
            text-shadow: 0 0 10px #00ff41;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        #info-panel .section {
            margin-bottom: 15px;
        }
        
        /* Enterprise Crew Selection Panel */
        #crew-selection {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff6b35;
            border-radius: 10px;
            padding: 20px;
            max-width: 350px;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #crew-selection h2 {
            color: #ff6b35;
            text-shadow: 0 0 10px #ff6b35;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .crew-member {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .crew-member:hover {
            background: rgba(255, 107, 53, 0.2);
        }
        
        .crew-member input[type="checkbox"] {
            margin-right: 10px;
            scale: 1.2;
        }
        
        .crew-member label {
            color: #ffffff;
            cursor: pointer;
            flex: 1;
        }
        
        .crew-rank {
            color: #ffd700;
            font-size: 0.8em;
            margin-left: 10px;
        }
        
        /* Object Information Panel */
        #object-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 20px;
            max-width: 400px;
            z-index: 100;
            backdrop-filter: blur(5px);
            display: none;
        }
        
        #object-info h3 {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        #object-info .info-item {
            margin-bottom: 8px;
            color: #ffffff;
        }
        
        #object-info .info-label {
            color: #00ff41;
            font-weight: bold;
            display: inline-block;
            width: 80px;
        }
        
        /* Story Management Panel */
        #story-panel {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 20px;
            max-width: 300px;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #story-panel h2 {
            color: #9b59b6;
            text-shadow: 0 0 10px #9b59b6;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .scene-button {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: rgba(155, 89, 182, 0.2);
            border: 1px solid #9b59b6;
            border-radius: 5px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .scene-button:hover {
            background: rgba(155, 89, 182, 0.4);
            transform: translateX(5px);
        }
        
        .scene-button.active {
            background: #9b59b6;
            box-shadow: 0 0 15px #9b59b6;
        }
            padding: 10px;
            background: rgba(0, 255, 65, 0.1);
            border-radius: 5px;
        }
        
        #info-panel .section h3 {
            color: #e94560;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        
        #info-panel .section p {
            color: #0f4c75;
            font-size: 0.8em;
            line-height: 1.4;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            border-radius: 10px;
            padding: 15px;
            z-index: 100;
        }
        
        #controls button {
            background: #00ff41;
            color: #1a1a2e;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8em;
            transition: all 0.3s ease;
        }
        
        #controls button:hover {
            background: #00cc33;
            box-shadow: 0 0 15px #00ff41;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff41;
            font-size: 1.5em;
            text-align: center;
            z-index: 200;
        }
        
        .hidden {
            display: none;
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        #environment-data {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #e94560;
            border-radius: 10px;
            padding: 20px;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #environment-data h2 {
            color: #e94560;
            text-shadow: 0 0 10px #e94560;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        #environment-data .data-section {
            margin-bottom: 12px;
            padding: 8px;
            background: rgba(233, 69, 96, 0.1);
            border-radius: 5px;
        }
        
        #environment-data .data-label {
            color: #00ff41;
            font-weight: bold;
            font-size: 0.8em;
        }
        
        #environment-data .data-value {
            color: #0f4c75;
            font-size: 0.75em;
            margin-top: 3px;
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f4c75;
            border-radius: 10px;
            padding: 15px;
            z-index: 100;
        }
        
        .legend h3 {
            color: #0f4c75;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.75em;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading" class="pulse hidden">
            üåå Loading Holodeck Environment...<br>
            <small>Connecting to LLM-powered 3D generation</small>
        </div>
        
        <div id="info-panel">
            <h1>üåü Holodeck 3D Visualizer</h1>
            <div class="section">
                <h3>üéÆ Controls</h3>
                <p>Mouse: Rotate view | Scroll: Zoom | Right-click drag: Pan</p>
            </div>
            <div class="section">
                <h3>üéØ Environment Features</h3>
                <p>‚Ä¢ Spatial bounds and terrain<br>
                ‚Ä¢ Key locations & navigation paths<br>
                ‚Ä¢ Interactive elements<br>
                ‚Ä¢ Lighting & atmospheric effects<br>
                ‚Ä¢ Physics boundaries</p>
            </div>
            <div class="section">
                <h3>‚ö° Real-time LLM</h3>
                <p id="llm-status">Waiting for environment data...</p>
            </div>
        </div>
        
        <div id="environment-data">
            <h2>üìä Environment Data</h2>
            <div id="data-content">
                <div class="data-section">
                    <div class="data-label">Status:</div>
                    <div class="data-value" id="env-status">No environment loaded</div>
                </div>
            </div>
        </div>
        
        <div id="controls">
            <button onclick="generateNewEnvironment()">üåç Generate New Environment</button>
            <button onclick="forceHideLoading()">üö´ Force Hide Loading</button>
            <button onclick="toggleLighting()">üí° Toggle Lighting</button>
            <button onclick="togglePhysics()">‚öΩ Toggle Physics</button>
            <button onclick="resetCamera()">üì∑ Reset Camera</button>
            <button onclick="exportEnvironment()">üíæ Export Data</button>
        </div>
        
        <div class="legend">
            <h3>üé® Legend</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: #00ff41;"></div>
                <span>Key Locations</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e94560;"></div>
                <span>Interactive Elements</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffd700;"></div>
                <span>Navigation Paths</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #0f4c75;"></div>
                <span>Physics Boundaries</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                <span>Light Sources</span>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let environmentData = null;
        let environmentObjects = [];
        let lightObjects = [];
        let physicsEnabled = true;
        let lightingEnabled = true;
        
        // Initialize Three.js scene
        function initThreeJS() {
            console.log('üé® Starting Three.js scene setup...');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 50, 200);
            console.log('‚úÖ Scene created');
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 20, 30);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            
            const container = document.getElementById('container');
            console.log('üîç Container element found:', !!container);
            if (container) {
                container.appendChild(renderer.domElement);
                console.log('‚úÖ Canvas added to container');
            } else {
                console.error('‚ùå Container element not found!');
            }
            
            // Controls setup (basic orbit controls simulation)
            setupBasicControls();
            
            // Add basic lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(100, 50, 0x00ff41, 0x0f4c75);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            // Add coordinate axes
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);
            
            // Start render loop
            animate();
        }
        
        function setupBasicControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;
            let radius = 50;
            let theta = 0;
            let phi = Math.PI / 3;
            
            renderer.domElement.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                theta += deltaX * 0.01;
                phi += deltaY * 0.01;
                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                
                updateCameraPosition();
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('wheel', (event) => {
                radius += event.deltaY * 0.05;
                radius = Math.max(5, Math.min(200, radius));
                updateCameraPosition();
            });
            
            function updateCameraPosition() {
                camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
                camera.position.y = radius * Math.cos(phi);
                camera.position.z = radius * Math.sin(phi) * Math.sin(theta);
                camera.lookAt(0, 0, 0);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Connect to holodeck-environment server and fetch environment data
        async function generateNewEnvironment() {
            const loadingElement = document.getElementById('loading');
            loadingElement.classList.remove('hidden');
            document.getElementById('llm-status').textContent = 'Generating environment with LLM...';
            
            try {
                const environmentTypes = ['starship', 'alien', 'fantasy', 'historical', 'space', 'training_facility'];
                const randomType = environmentTypes[Math.floor(Math.random() * environmentTypes.length)];
                
                // Create WebSocket connection
                const websocket = new WebSocket('ws://localhost:8445/mcp');
                let requestCompleted = false;
                
                await new Promise((resolve, reject) => {
                    websocket.onopen = () => {
                        console.log('WebSocket connected to holodeck-environment server');
                        
                        // Send environment generation request
                        const request = {
                            type: 'envelope',
                            payload: {
                                meta: {
                                    request_id: generateUUID(),
                                    tenant: 'holodeck-3d-visualizer',
                                    timestamp: new Date().toISOString(),
                                    version: '1.0.0'
                                },
                                data: {
                                    tool_call: {
                                        method: 'tools/call',
                                        params: {
                                            name: 'generate_environment',
                                            arguments: {
                                                scene_description: `A detailed ${randomType} environment with rich 3D spatial layout`,
                                                environment_type: randomType,
                                                safety_level: 'standard',
                                                request_id: generateUUID()
                                            }
                                        }
                                    }
                                }
                            }
                        };
                        
                        websocket.send(JSON.stringify(request));
                    };
                    
                    websocket.onmessage = (event) => {
                        console.log('üî• WebSocket message received!', event.data.length, 'characters');
                        try {
                            const response = JSON.parse(event.data);
                            console.log('Full response structure:', JSON.stringify(response, null, 2));
                            
                            // Extract environment data from response - try multiple paths
                            let environmentData = null;
                            let rawText = null;
                            
                            // Path 1: Standard qollective envelope format - raw.text
                            if (response.payload && response.payload.data && response.payload.data.tool_response) {
                                const toolResponse = response.payload.data.tool_response;
                                console.log('Tool response:', toolResponse);
                                
                                if (toolResponse.content && toolResponse.content[0]) {
                                    // Try raw.text format first
                                    if (toolResponse.content[0].raw && toolResponse.content[0].raw.text) {
                                        rawText = toolResponse.content[0].raw.text;
                                        console.log('Raw text (raw.text):', rawText);
                                    }
                                    // Try direct text format
                                    else if (toolResponse.content[0].text) {
                                        rawText = toolResponse.content[0].text;
                                        console.log('Raw text (direct text):', rawText);
                                    }
                                }
                            }
                            
                            // Path 2: Direct data format
                            if (!rawText && response.data && response.data.tool_response) {
                                const toolResponse = response.data.tool_response;
                                if (toolResponse.content && toolResponse.content[0]) {
                                    // Try raw.text format first
                                    if (toolResponse.content[0].raw && toolResponse.content[0].raw.text) {
                                        rawText = toolResponse.content[0].raw.text;
                                        console.log('Raw text (path 2 - raw.text):', rawText);
                                    }
                                    // Try direct text format
                                    else if (toolResponse.content[0].text) {
                                        rawText = toolResponse.content[0].text;
                                        console.log('Raw text (path 2 - direct text):', rawText);
                                    }
                                }
                            }
                            
                            if (rawText) {
                                try {
                                    environmentData = JSON.parse(rawText);
                                    console.log('Parsed environment data:', environmentData);
                                    
                                    console.log('üé® Starting 3D visualization...');
                                    visualizeEnvironment(environmentData);
                                    console.log('üìä Updating data panel...');
                                    updateEnvironmentDataPanel(environmentData);
                                    
                                    console.log('üéØ Setting status message...');
                                    document.getElementById('llm-status').textContent = `‚úÖ ${environmentData.environment.environment_type} environment generated!`;
                                    console.log('üö´ Hiding loading indicator...');
                                    console.log('Loading element before hiding:', loadingElement);
                                    console.log('Loading element classes before:', loadingElement.className);
                                    loadingElement.classList.add('hidden');
                                    loadingElement.style.display = 'none';
                                    loadingElement.style.visibility = 'hidden';
                                    console.log('Loading element classes after:', loadingElement.className);
                                    console.log('Loading element style after:', loadingElement.style.display);
                                    console.log('‚úÖ Environment generation completed successfully!');
                                    requestCompleted = true;
                                    resolve();
                                } catch (jsonError) {
                                    console.error('Failed to parse environment JSON:', jsonError);
                                    console.log('Raw text that failed to parse:', rawText);
                                    throw jsonError;
                                }
                            } else {
                                console.error('Could not find environment data in response');
                                console.log('Available response keys:', Object.keys(response));
                                if (response.payload) {
                                    console.log('Payload keys:', Object.keys(response.payload));
                                    if (response.payload.data) {
                                        console.log('Data keys:', Object.keys(response.payload.data));
                                    }
                                }
                                throw new Error('Environment data not found in response');
                            }
                        } catch (parseError) {
                            console.error('Error processing response:', parseError);
                            console.log('Raw response data:', event.data);
                            reject(parseError);
                        }
                        
                        // Don't close WebSocket immediately - wait a bit
                        setTimeout(() => {
                            websocket.close();
                        }, 1000);
                    };
                    
                    websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        reject(error);
                    };
                    
                    websocket.onclose = (event) => {
                        if (event.code !== 1000) {
                            console.error('WebSocket closed unexpectedly:', event.code, event.reason);
                        }
                    };
                    
                    // Timeout after 60 seconds (allow for slower LLM responses)
                    setTimeout(() => {
                        if (!requestCompleted) {
                            reject(new Error('Request timeout'));
                        }
                    }, 60000);
                });
                
            } catch (error) {
                console.error('Error generating environment:', error);
                document.getElementById('llm-status').textContent = '‚ùå Failed to connect to server';
                
                // Generate demo environment for visualization
                console.log('üéÆ Loading demo environment as fallback...');
                generateDemoEnvironment();
                loadingElement.classList.add('hidden');
                loadingElement.style.display = 'none';
            }
            
            console.log('üèÅ generateNewEnvironment() function completed');
        }
        
        function generateDemoEnvironment() {
            environmentData = {
                environment: {
                    scene_description: "Demo Star Trek Enterprise bridge with tactical stations and viewscreen",
                    environment_type: "starship",
                    safety_level: "standard",
                    spatial_layout: {
                        bounds: {
                            min_point: [-25, 0, -25],
                            max_point: [25, 20, 25],
                            center: [0, 10, 0],
                            total_volume_cubic_meters: 25000
                        },
                        key_locations: [
                            { name: "Captain's Chair", position: [0, 1, 0], description: "Command center", interaction_type: "Activate", safety_zone: true },
                            { name: "Tactical Station", position: [-5, 1, -8], description: "Weapons and shields", interaction_type: "Manipulate", safety_zone: true },
                            { name: "Engineering Console", position: [8, 1, -5], description: "Ship systems", interaction_type: "Manipulate", safety_zone: true },
                            { name: "Viewscreen", position: [0, 8, -15], description: "Main display", interaction_type: "Examine", safety_zone: true }
                        ],
                        navigation_paths: [
                            { path_id: "bridge-walk", waypoints: [[-10, 1, -10], [0, 1, 0], [10, 1, -10]], path_type: "Walking", safety_level: "standard" }
                        ],
                        elevation_map: {
                            grid_resolution: 1.0,
                            height_values: Array(20).fill().map(() => Array(20).fill(0.1)),
                            surface_materials: Array(20).fill().map(() => Array(20).fill("Synthetic"))
                        }
                    },
                    atmospheric_conditions: {
                        temperature_celsius: 21,
                        humidity_percent: 45,
                        atmospheric_pressure: 101325,
                        lighting_conditions: {
                            ambient_intensity: 0.4,
                            directional_lights: [
                                { direction: [0, -1, -0.5], intensity: 0.8, color: { r: 0.9, g: 0.9, b: 1.0 }, shadows_enabled: true }
                            ],
                            point_lights: [
                                { position: [0, 15, 0], intensity: 1.2, color: { r: 0.8, g: 0.9, b: 1.0 }, attenuation_radius: 30 },
                                { position: [-10, 5, -10], intensity: 0.6, color: { r: 0.0, g: 0.5, b: 1.0 }, attenuation_radius: 15 }
                            ],
                            mood: "Natural",
                            time_of_day_factor: 0.5
                        }
                    },
                    interactive_elements: [
                        { element_id: "console1", name: "Command Console", position: [0, 1.2, 0], interaction_type: "Activate", description: "Primary command interface" },
                        { element_id: "screen1", name: "Status Display", position: [5, 3, -8], interaction_type: "Examine", description: "Ship status monitor" }
                    ]
                }
            };
            
            visualizeEnvironment(environmentData);
            updateEnvironmentDataPanel(environmentData);
            document.getElementById('llm-status').textContent = 'üéÆ Demo environment loaded with characters';
            
            // Hide loading indicator for demo environment too
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.classList.add('hidden');
                loadingElement.style.display = 'none';
            }
        }
        
        // Function to create realistic 3D human characters
        function createHumanCharacter(config = {}) {
            const human = new THREE.Group();
            
            const skinColor = config.skinColor || 0xfdbcb4;
            const clothingColor = config.clothingColor || 0x4a90e2;
            const hairColor = config.hairColor || 0x8b4513;
            const scale = config.scale || 1;
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.5 * scale, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ color: skinColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 7.5 * scale;
            human.add(head);
            
            // Hair
            const hairGeometry = new THREE.SphereGeometry(0.52 * scale, 16, 16);
            const hairMaterial = new THREE.MeshPhongMaterial({ color: hairColor });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 7.7 * scale;
            hair.scale.set(1, 0.8, 1);
            human.add(hair);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08 * scale, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.15 * scale, 7.6 * scale, 0.4 * scale);
            human.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.15 * scale, 7.6 * scale, 0.4 * scale);
            human.add(rightEye);
            
            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(0.8 * scale, 1.0 * scale, 3 * scale, 12);
            const torsoMaterial = new THREE.MeshPhongMaterial({ color: clothingColor });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.y = 5 * scale;
            human.add(torso);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.2 * scale, 0.25 * scale, 2.5 * scale, 8);
            const armMaterial = new THREE.MeshPhongMaterial({ color: skinColor });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-1.2 * scale, 5.5 * scale, 0);
            leftArm.rotation.z = 0.3;
            human.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(1.2 * scale, 5.5 * scale, 0);
            rightArm.rotation.z = -0.3;
            human.add(rightArm);
            
            // Hands
            const handGeometry = new THREE.SphereGeometry(0.15 * scale, 8, 8);
            const handMaterial = new THREE.MeshPhongMaterial({ color: skinColor });
            
            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(-1.6 * scale, 4.2 * scale, 0.2 * scale);
            human.add(leftHand);
            
            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(1.6 * scale, 4.2 * scale, 0.2 * scale);
            human.add(rightHand);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.25 * scale, 0.3 * scale, 3.5 * scale, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: clothingColor });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.4 * scale, 2 * scale, 0);
            human.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.4 * scale, 2 * scale, 0);
            human.add(rightLeg);
            
            // Feet
            const footGeometry = new THREE.BoxGeometry(0.8 * scale, 0.3 * scale, 0.5 * scale);
            const footMaterial = new THREE.MeshPhongMaterial({ color: 0x2c3e50 });
            
            const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
            leftFoot.position.set(-0.4 * scale, 0.2 * scale, 0.2 * scale);
            human.add(leftFoot);
            
            const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
            rightFoot.position.set(0.4 * scale, 0.2 * scale, 0.2 * scale);
            human.add(rightFoot);
            
            // Add name tag
            if (config.name) {
                const nametagGeometry = new THREE.PlaneGeometry(2 * scale, 0.5 * scale);
                const nametagCanvas = document.createElement('canvas');
                nametagCanvas.width = 200;
                nametagCanvas.height = 50;
                const nametagCtx = nametagCanvas.getContext('2d');
                
                // Background
                nametagCtx.fillStyle = 'rgba(0, 100, 200, 0.8)';
                nametagCtx.fillRect(0, 0, 200, 50);
                nametagCtx.strokeStyle = '#ffffff';
                nametagCtx.lineWidth = 2;
                nametagCtx.strokeRect(0, 0, 200, 50);
                
                // Text
                nametagCtx.fillStyle = '#ffffff';
                nametagCtx.font = 'bold 16px Arial';
                nametagCtx.textAlign = 'center';
                nametagCtx.fillText(config.name, 100, 30);
                
                const nametagTexture = new THREE.CanvasTexture(nametagCanvas);
                const nametagMaterial = new THREE.MeshBasicMaterial({ 
                    map: nametagTexture, 
                    transparent: true 
                });
                const nametag = new THREE.Mesh(nametagGeometry, nametagMaterial);
                nametag.position.set(0, 8.5 * scale, 0);
                nametag.lookAt(camera.position);
                human.add(nametag);
            }
            
            return human;
        }
        
        // Function to create diverse human characters
        function createDiverseCharacter(type = 'default', name = '') {
            const configs = {
                scientist: {
                    skinColor: 0xfdbcb4,
                    clothingColor: 0xffffff,
                    hairColor: 0x654321,
                    name: name || 'Scientist',
                    scale: 0.8
                },
                engineer: {
                    skinColor: 0xe8b896,
                    clothingColor: 0xff6b35,
                    hairColor: 0x2c1810,
                    name: name || 'Engineer',
                    scale: 0.9
                },
                officer: {
                    skinColor: 0xd4a574,
                    clothingColor: 0x1e3a8a,
                    hairColor: 0x8b4513,
                    name: name || 'Officer',
                    scale: 1.0
                },
                civilian: {
                    skinColor: 0xf2d7c4,
                    clothingColor: 0x10b981,
                    hairColor: 0x4a5568,
                    name: name || 'Civilian',
                    scale: 0.85
                },
                alien: {
                    skinColor: 0x7dd3c0,
                    clothingColor: 0x553c9a,
                    hairColor: 0x1a202c,
                    name: name || 'Alien Resident',
                    scale: 1.1
                }
            };
            
            return createHumanCharacter(configs[type] || configs.default);
        }
        
        function visualizeEnvironment(envData) {
            // Clear existing environment objects
            environmentObjects.forEach(obj => scene.remove(obj));
            lightObjects.forEach(light => scene.remove(light));
            environmentObjects = [];
            lightObjects = [];
            
            const env = envData.environment;
            
            // 1. Visualize spatial bounds - ENHANCED
            if (env.spatial_layout && env.spatial_layout.bounds) {
                const bounds = env.spatial_layout.bounds;
                const size = [
                    bounds.max_point[0] - bounds.min_point[0],
                    bounds.max_point[1] - bounds.min_point[1],
                    bounds.max_point[2] - bounds.min_point[2]
                ];
                
                console.log('üèóÔ∏è Creating bounding box:', { size, center: bounds.center, bounds });
                
                // Create wireframe bounding box
                const geometry = new THREE.BoxGeometry(size[0], size[1], size[2]);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    wireframe: true, 
                    opacity: 0.8, 
                    transparent: true 
                });
                const boundingBox = new THREE.Mesh(geometry, material);
                boundingBox.position.set(bounds.center[0], bounds.center[1], bounds.center[2]);
                scene.add(boundingBox);
                environmentObjects.push(boundingBox);
                
                // Add corner markers to make bounds more visible
                const corners = [
                    bounds.min_point,
                    [bounds.max_point[0], bounds.min_point[1], bounds.min_point[2]],
                    [bounds.min_point[0], bounds.max_point[1], bounds.min_point[2]],
                    [bounds.min_point[0], bounds.min_point[1], bounds.max_point[2]],
                    [bounds.max_point[0], bounds.max_point[1], bounds.min_point[2]],
                    [bounds.max_point[0], bounds.min_point[1], bounds.max_point[2]],
                    [bounds.min_point[0], bounds.max_point[1], bounds.max_point[2]],
                    bounds.max_point
                ];
                
                corners.forEach((corner, index) => {
                    const cornerGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                    const cornerMaterial = new THREE.MeshBasicMaterial({ color: 0xff6b6b });
                    const cornerMarker = new THREE.Mesh(cornerGeometry, cornerMaterial);
                    cornerMarker.position.set(corner[0], corner[1], corner[2]);
                    scene.add(cornerMarker);
                    environmentObjects.push(cornerMarker);
                });
                
                // Position camera to see the entire environment
                const maxDimension = Math.max(...size);
                camera.position.set(
                    bounds.center[0] + maxDimension * 0.7,
                    bounds.center[1] + maxDimension * 0.5,
                    bounds.center[2] + maxDimension * 0.7
                );
                camera.lookAt(bounds.center[0], bounds.center[1], bounds.center[2]);
                console.log('üì∑ Camera positioned at:', camera.position, 'looking at:', bounds.center);
            }
            
            // 1.5. Add enhanced ground plane with texture
            if (env.spatial_layout && env.spatial_layout.bounds) {
                const bounds = env.spatial_layout.bounds;
                const size = [
                    bounds.max_point[0] - bounds.min_point[0],
                    bounds.max_point[2] - bounds.min_point[2]  // X and Z dimensions
                ];
                
                // Create textured ground
                const groundGeometry = new THREE.PlaneGeometry(size[0], size[1], 32, 32);
                
                // Create procedural ground texture
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Base alien terrain color
                const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
                gradient.addColorStop(0, '#34495e');
                gradient.addColorStop(0.5, '#2c3e50');
                gradient.addColorStop(1, '#1a252f');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);
                
                // Add alien pattern details
                ctx.fillStyle = 'rgba(46, 204, 113, 0.1)';
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    const radius = Math.random() * 20 + 5;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add circuit-like alien patterns
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.3)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 20; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * 512, Math.random() * 512);
                    for (let j = 0; j < 5; j++) {
                        ctx.lineTo(Math.random() * 512, Math.random() * 512);
                    }
                    ctx.stroke();
                }
                
                const groundTexture = new THREE.CanvasTexture(canvas);
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(2, 2);
                
                const groundMaterial = new THREE.MeshPhongMaterial({ 
                    map: groundTexture,
                    transparent: true, 
                    opacity: 0.8,
                    side: THREE.DoubleSide,
                    shininess: 10
                });
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
                ground.position.set(bounds.center[0], bounds.min_point[1], bounds.center[2]);
                scene.add(ground);
                environmentObjects.push(ground);
                console.log('üåç Enhanced ground plane added at:', ground.position);
                
                // Add atmospheric particles
                const particleCount = 200;
                const particleGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * size[0];     // x
                    positions[i + 1] = Math.random() * 30 + 5;          // y
                    positions[i + 2] = (Math.random() - 0.5) * size[1]; // z
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: 0x00ff88,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const particles = new THREE.Points(particleGeometry, particleMaterial);
                particles.position.set(bounds.center[0], bounds.center[1], bounds.center[2]);
                scene.add(particles);
                environmentObjects.push(particles);
            }
            
            // 2. Visualize key locations - ENHANCED with detailed structures
            if (env.spatial_layout && env.spatial_layout.key_locations) {
                env.spatial_layout.key_locations.forEach(location => {
                    // Create detailed location structures instead of simple spheres
                    const group = new THREE.Group();
                    
                    if (location.name.includes('Central') || location.name.includes('Area')) {
                        // Central Area - Create a detailed platform structure
                        const platformGeom = new THREE.CylinderGeometry(8, 10, 1, 16);
                        const platformMat = new THREE.MeshPhongMaterial({ 
                            color: 0x34495e,
                            shininess: 30,
                            transparent: true,
                            opacity: 0.8
                        });
                        const platform = new THREE.Mesh(platformGeom, platformMat);
                        platform.position.y = -0.5;
                        group.add(platform);
                        
                        // Add pillars around the platform
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const pillarGeom = new THREE.CylinderGeometry(0.3, 0.4, 4, 8);
                            const pillarMat = new THREE.MeshPhongMaterial({ color: 0x2c3e50 });
                            const pillar = new THREE.Mesh(pillarGeom, pillarMat);
                            pillar.position.x = Math.cos(angle) * 7;
                            pillar.position.z = Math.sin(angle) * 7;
                            pillar.position.y = 2;
                            group.add(pillar);
                        }
                        
                        // Add central beacon
                        const beaconGeom = new THREE.ConeGeometry(1, 6, 8);
                        const beaconMat = new THREE.MeshPhongMaterial({ 
                            color: 0x00ff41,
                            emissive: 0x002200,
                            transparent: true,
                            opacity: 0.9
                        });
                        const beacon = new THREE.Mesh(beaconGeom, beaconMat);
                        beacon.position.y = 4;
                        group.add(beacon);
                        
                    } else if (location.name.includes('Observation') || location.name.includes('Point')) {
                        // Observation Point - Create a detailed tower structure
                        const towerBase = new THREE.CylinderGeometry(4, 5, 2, 12);
                        const towerBaseMat = new THREE.MeshPhongMaterial({ color: 0x34495e });
                        const base = new THREE.Mesh(towerBase, towerBaseMat);
                        base.position.y = 1;
                        group.add(base);
                        
                        const towerMid = new THREE.CylinderGeometry(2.5, 3.5, 8, 12);
                        const towerMidMat = new THREE.MeshPhongMaterial({ color: 0x2c3e50 });
                        const mid = new THREE.Mesh(towerMid, towerMidMat);
                        mid.position.y = 6;
                        group.add(mid);
                        
                        // Observation deck
                        const deckGeom = new THREE.CylinderGeometry(3.5, 3.5, 1, 12);
                        const deckMat = new THREE.MeshPhongMaterial({ 
                            color: 0x27ae60,
                            transparent: true,
                            opacity: 0.8
                        });
                        const deck = new THREE.Mesh(deckGeom, deckMat);
                        deck.position.y = 10.5;
                        group.add(deck);
                        
                        // Railing
                        const railGeom = new THREE.TorusGeometry(3.8, 0.1, 8, 16);
                        const railMat = new THREE.MeshPhongMaterial({ color: 0xbdc3c7 });
                        const rail = new THREE.Mesh(railGeom, railMat);
                        rail.position.y = 11.5;
                        group.add(rail);
                        
                    } else {
                        // Generic location - Enhanced structure
                        const baseGeom = new THREE.BoxGeometry(4, 1, 4);
                        const baseMat = new THREE.MeshPhongMaterial({ color: 0x34495e });
                        const base = new THREE.Mesh(baseGeom, baseMat);
                        base.position.y = 0.5;
                        group.add(base);
                        
                        const markerGeom = new THREE.SphereGeometry(1.5, 32, 32);
                        const markerMat = new THREE.MeshPhongMaterial({ 
                            color: location.safety_zone ? 0x00ff41 : 0xffaa00,
                            shininess: 100,
                            transparent: true,
                            opacity: 0.9
                        });
                        const marker = new THREE.Mesh(markerGeom, markerMat);
                        marker.position.y = 2.5;
                        group.add(marker);
                    }
                    
                    group.position.set(location.position[0], location.position[1], location.position[2]);
                    group.userData = { type: 'key_location', data: location };
                    scene.add(group);
                    environmentObjects.push(group);
                    
                    // Enhanced label with better styling
                    const labelGeometry = new THREE.PlaneGeometry(6, 1.5);
                    const canvas = document.createElement('canvas');
                    canvas.width = 400;
                    canvas.height = 100;
                    const context = canvas.getContext('2d');
                    
                    // Create gradient background
                    const gradient = context.createLinearGradient(0, 0, 400, 0);
                    gradient.addColorStop(0, 'rgba(0, 255, 65, 0.8)');
                    gradient.addColorStop(1, 'rgba(0, 200, 50, 0.6)');
                    context.fillStyle = gradient;
                    context.fillRect(0, 0, 400, 100);
                    
                    // Add border
                    context.strokeStyle = '#00ff41';
                    context.lineWidth = 3;
                    context.strokeRect(0, 0, 400, 100);
                    
                    // Add text
                    context.fillStyle = '#ffffff';
                    context.font = 'bold 28px Arial';
                    context.textAlign = 'center';
                    context.fillText(location.name, 200, 40);
                    context.font = '18px Arial';
                    context.fillText(location.description || 'Key Location', 200, 70);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const labelMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                    const label = new THREE.Mesh(labelGeometry, labelMaterial);
                    label.position.set(location.position[0], location.position[1] + 8, location.position[2]);
                    label.lookAt(camera.position);
                    scene.add(label);
                    environmentObjects.push(label);
                });
            }
            
            // 3. Visualize navigation paths - ENHANCED
            if (env.spatial_layout && env.spatial_layout.navigation_paths) {
                env.spatial_layout.navigation_paths.forEach(path => {
                    console.log('üõ§Ô∏è Creating navigation path:', path);
                    const points = path.waypoints.map(wp => new THREE.Vector3(wp[0], wp[1], wp[2]));
                    
                    // Create thick line for better visibility
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ 
                        color: 0xffd700, 
                        linewidth: 5,
                        transparent: true,
                        opacity: 0.9
                    });
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    environmentObjects.push(line);
                    
                    // Add bigger waypoint markers
                    points.forEach((point, index) => {
                        const markerGeometry = new THREE.ConeGeometry(1, 2, 8);
                        const markerMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
                        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                        marker.position.copy(point);
                        marker.position.y += 1; // Lift slightly above ground
                        scene.add(marker);
                        environmentObjects.push(marker);
                        
                        // Add waypoint labels
                        const labelGeometry = new THREE.PlaneGeometry(3, 0.8);
                        const canvas = document.createElement('canvas');
                        canvas.width = 200;
                        canvas.height = 50;
                        const context = canvas.getContext('2d');
                        context.fillStyle = '#ffd700';
                        context.font = '20px monospace';
                        context.fillText(`Waypoint ${index + 1}`, 5, 30);
                        const texture = new THREE.CanvasTexture(canvas);
                        const labelMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                        const label = new THREE.Mesh(labelGeometry, labelMaterial);
                        label.position.copy(point);
                        label.position.y += 3;
                        label.lookAt(camera.position);
                        scene.add(label);
                        environmentObjects.push(label);
                    });
                });
            }
            
            // 4. Visualize interactive elements - ENHANCED with detailed control panels
            if (env.interactive_elements) {
                env.interactive_elements.forEach(element => {
                    const group = new THREE.Group();
                    
                    if (element.name.includes('Control') || element.name.includes('Panel')) {
                        // Create detailed control panel structure
                        const baseGeom = new THREE.BoxGeometry(3, 2.5, 0.3);
                        const baseMat = new THREE.MeshPhongMaterial({ 
                            color: 0x2c3e50,
                            shininess: 50
                        });
                        const base = new THREE.Mesh(baseGeom, baseMat);
                        group.add(base);
                        
                        // Add screen
                        const screenGeom = new THREE.BoxGeometry(2.5, 1.8, 0.05);
                        const screenMat = new THREE.MeshPhongMaterial({ 
                            color: 0x1a1a1a,
                            emissive: 0x003300,
                            transparent: true,
                            opacity: 0.9
                        });
                        const screen = new THREE.Mesh(screenGeom, screenMat);
                        screen.position.z = 0.2;
                        group.add(screen);
                        
                        // Add control buttons
                        for (let i = 0; i < 6; i++) {
                            const buttonGeom = new THREE.CylinderGeometry(0.1, 0.1, 0.1, 8);
                            const buttonMat = new THREE.MeshPhongMaterial({ 
                                color: i < 2 ? 0xe74c3c : (i < 4 ? 0xf39c12 : 0x27ae60),
                                emissive: i < 2 ? 0x330000 : (i < 4 ? 0x332200 : 0x003300)
                            });
                            const button = new THREE.Mesh(buttonGeom, buttonMat);
                            button.position.x = -1 + (i % 3) * 1;
                            button.position.y = -0.6 + Math.floor(i / 3) * 0.4;
                            button.position.z = 0.25;
                            button.rotation.x = Math.PI / 2;
                            group.add(button);
                        }
                        
                        // Add holographic display effect
                        const holoGeom = new THREE.PlaneGeometry(2, 1.5);
                        const holoCanvas = document.createElement('canvas');
                        holoCanvas.width = 256;
                        holoCanvas.height = 192;
                        const holoCtx = holoCanvas.getContext('2d');
                        
                        // Create holographic effect
                        const holoGradient = holoCtx.createLinearGradient(0, 0, 0, 192);
                        holoGradient.addColorStop(0, 'rgba(0, 255, 100, 0.8)');
                        holoGradient.addColorStop(0.5, 'rgba(0, 200, 255, 0.6)');
                        holoGradient.addColorStop(1, 'rgba(0, 255, 100, 0.8)');
                        holoCtx.fillStyle = holoGradient;
                        holoCtx.fillRect(0, 0, 256, 192);
                        
                        // Add scan lines
                        for (let y = 0; y < 192; y += 4) {
                            holoCtx.fillStyle = 'rgba(0, 255, 150, 0.3)';
                            holoCtx.fillRect(0, y, 256, 1);
                        }
                        
                        // Add text
                        holoCtx.fillStyle = '#ffffff';
                        holoCtx.font = '16px monospace';
                        holoCtx.fillText('ZYLATHAR PRIME', 50, 30);
                        holoCtx.fillText('CONTROL ACTIVE', 50, 50);
                        holoCtx.fillText('STATUS: NOMINAL', 50, 70);
                        
                        const holoTexture = new THREE.CanvasTexture(holoCanvas);
                        const holoMat = new THREE.MeshBasicMaterial({ 
                            map: holoTexture, 
                            transparent: true,
                            opacity: 0.9
                        });
                        const holo = new THREE.Mesh(holoGeom, holoMat);
                        holo.position.z = 0.3;
                        group.add(holo);
                        
                    } else {
                        // Generic interactive element - Enhanced design
                        const baseGeom = new THREE.BoxGeometry(2.5, 1.5, 1.5);
                        const baseMat = new THREE.MeshPhongMaterial({ 
                            color: 0xe94560,
                            shininess: 60,
                            transparent: true,
                            opacity: 0.9
                        });
                        const base = new THREE.Mesh(baseGeom, baseMat);
                        group.add(base);
                        
                        // Add interactive indicator
                        const indicatorGeom = new THREE.SphereGeometry(0.3, 16, 16);
                        const indicatorMat = new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00,
                            emissive: 0x002200,
                            transparent: true,
                            opacity: 0.8
                        });
                        const indicator = new THREE.Mesh(indicatorGeom, indicatorMat);
                        indicator.position.y = 1;
                        group.add(indicator);
                    }
                    
                    group.position.set(element.position[0], element.position[1], element.position[2]);
                    group.userData = { type: 'interactive_element', data: element };
                    scene.add(group);
                    environmentObjects.push(group);
                });
            }
            
            // 5. Visualize lighting
            if (env.atmospheric_conditions && env.atmospheric_conditions.lighting_conditions) {
                const lighting = env.atmospheric_conditions.lighting_conditions;
                
                // Update ambient light
                scene.children.forEach(child => {
                    if (child instanceof THREE.AmbientLight) {
                        child.intensity = lighting.ambient_intensity;
                    }
                });
                
                // Add directional lights
                if (lighting.directional_lights) {
                    lighting.directional_lights.forEach(dirLight => {
                        const light = new THREE.DirectionalLight(
                            new THREE.Color(dirLight.color.r, dirLight.color.g, dirLight.color.b),
                            dirLight.intensity
                        );
                        light.position.set(-dirLight.direction[0] * 20, -dirLight.direction[1] * 20, -dirLight.direction[2] * 20);
                        light.castShadow = dirLight.shadows_enabled;
                        scene.add(light);
                        lightObjects.push(light);
                        
                        // Add helper
                        const helper = new THREE.DirectionalLightHelper(light, 5, 0xff6b6b);
                        scene.add(helper);
                        lightObjects.push(helper);
                    });
                }
                
                // Add point lights
                if (lighting.point_lights) {
                    lighting.point_lights.forEach(pointLight => {
                        const light = new THREE.PointLight(
                            new THREE.Color(pointLight.color.r, pointLight.color.g, pointLight.color.b),
                            pointLight.intensity,
                            pointLight.attenuation_radius
                        );
                        light.position.set(pointLight.position[0], pointLight.position[1], pointLight.position[2]);
                        light.castShadow = true;
                        scene.add(light);
                        lightObjects.push(light);
                        
                        // Add visual representation
                        const geometry = new THREE.SphereGeometry(0.5, 8, 8);
                        const material = new THREE.MeshBasicMaterial({ 
                            color: new THREE.Color(pointLight.color.r, pointLight.color.g, pointLight.color.b)
                        });
                        const lightSphere = new THREE.Mesh(geometry, material);
                        lightSphere.position.copy(light.position);
                        scene.add(lightSphere);
                        lightObjects.push(lightSphere);
                    });
                }
            }
            
            // 6. Add terrain/elevation map visualization
            if (env.spatial_layout && env.spatial_layout.elevation_map) {
                const elevationMap = env.spatial_layout.elevation_map;
                const size = 50;
                const geometry = new THREE.PlaneGeometry(size, size, elevationMap.height_values.length - 1, elevationMap.height_values[0].length - 1);
                const vertices = geometry.attributes.position.array;
                
                // Apply height values
                for (let i = 0; i < elevationMap.height_values.length; i++) {
                    for (let j = 0; j < elevationMap.height_values[i].length; j++) {
                        const index = (i * elevationMap.height_values[0].length + j) * 3 + 2;
                        if (index < vertices.length) {
                            vertices[index] = elevationMap.height_values[i][j] * 5; // Scale height
                        }
                    }
                }
                
                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x2d2d2d,
                    wireframe: false,
                    transparent: true,
                    opacity: 0.7
                });
                const terrain = new THREE.Mesh(geometry, material);
                terrain.rotation.x = -Math.PI / 2;
                terrain.position.y = -1;
                scene.add(terrain);
                environmentObjects.push(terrain);
            }
            
            // 7. Add human characters to populate the environment
            if (env.spatial_layout && env.spatial_layout.key_locations) {
                // Add characters at key locations
                env.spatial_layout.key_locations.forEach((location, index) => {
                    // Add 1-3 characters per location
                    const numCharacters = Math.floor(Math.random() * 3) + 1;
                    
                    for (let i = 0; i < numCharacters; i++) {
                        const characterTypes = ['scientist', 'engineer', 'officer', 'civilian', 'alien'];
                        const randomType = characterTypes[Math.floor(Math.random() * characterTypes.length)];
                        
                        const character = createDiverseCharacter(randomType);
                        
                        // Position characters around the location
                        const offsetX = (Math.random() - 0.5) * 8;
                        const offsetZ = (Math.random() - 0.5) * 8;
                        
                        character.position.set(
                            location.position[0] + offsetX,
                            location.position[1],
                            location.position[2] + offsetZ
                        );
                        
                        // Random rotation for variety
                        character.rotation.y = Math.random() * Math.PI * 2;
                        
                        scene.add(character);
                        environmentObjects.push(character);
                        console.log(`üë§ Added ${randomType} character at location:`, location.name);
                    }
                });
            }
            
            // Add some wandering characters throughout the environment
            if (env.spatial_layout && env.spatial_layout.bounds) {
                const bounds = env.spatial_layout.bounds;
                const numWanderingCharacters = 5 + Math.floor(Math.random() * 8); // 5-12 characters
                
                for (let i = 0; i < numWanderingCharacters; i++) {
                    const characterTypes = ['scientist', 'engineer', 'officer', 'civilian', 'alien'];
                    const randomType = characterTypes[Math.floor(Math.random() * characterTypes.length)];
                    
                    const character = createDiverseCharacter(randomType, `Person ${i + 1}`);
                    
                    // Random position within bounds
                    const x = bounds.min_point[0] + Math.random() * (bounds.max_point[0] - bounds.min_point[0]);
                    const z = bounds.min_point[2] + Math.random() * (bounds.max_point[2] - bounds.min_point[2]);
                    const y = bounds.min_point[1]; // Ground level
                    
                    character.position.set(x, y, z);
                    character.rotation.y = Math.random() * Math.PI * 2;
                    
                    scene.add(character);
                    environmentObjects.push(character);
                }
                
                console.log(`üë• Added ${numWanderingCharacters} wandering characters throughout the environment`);
            }
            
            // 8. Add Enterprise crew members
            createEnterpriseCrewCharacters();
            
            console.log('‚úÖ Environment visualization completed with human characters and Enterprise crew');
        }
        
        function updateEnvironmentDataPanel(envData) {
            const dataContent = document.getElementById('data-content');
            const env = envData.environment;
            
            let html = `
                <div class="data-section">
                    <div class="data-label">Environment Type:</div>
                    <div class="data-value">${env.environment_type}</div>
                </div>
                <div class="data-section">
                    <div class="data-label">Safety Level:</div>
                    <div class="data-value">${env.safety_level}</div>
                </div>
                <div class="data-section">
                    <div class="data-label">Description:</div>
                    <div class="data-value">${env.scene_description}</div>
                </div>
            `;
            
            if (env.spatial_layout) {
                html += `
                    <div class="data-section">
                        <div class="data-label">Spatial Bounds:</div>
                        <div class="data-value">
                            Size: ${(env.spatial_layout.bounds.max_point[0] - env.spatial_layout.bounds.min_point[0]).toFixed(1)}m √ó 
                            ${(env.spatial_layout.bounds.max_point[1] - env.spatial_layout.bounds.min_point[1]).toFixed(1)}m √ó 
                            ${(env.spatial_layout.bounds.max_point[2] - env.spatial_layout.bounds.min_point[2]).toFixed(1)}m<br>
                            Volume: ${env.spatial_layout.bounds.total_volume_cubic_meters.toFixed(0)} m¬≥
                        </div>
                    </div>
                    <div class="data-section">
                        <div class="data-label">Key Locations:</div>
                        <div class="data-value">${env.spatial_layout.key_locations ? env.spatial_layout.key_locations.length : 0} locations</div>
                    </div>
                `;
            }
            
            if (env.atmospheric_conditions) {
                html += `
                    <div class="data-section">
                        <div class="data-label">Temperature:</div>
                        <div class="data-value">${env.atmospheric_conditions.temperature_celsius}¬∞C</div>
                    </div>
                    <div class="data-section">
                        <div class="data-label">Lighting Mood:</div>
                        <div class="data-value">${env.atmospheric_conditions.lighting_conditions.mood}</div>
                    </div>
                `;
            }
            
            html += `
                <div class="data-section">
                    <div class="data-label">Interactive Elements:</div>
                    <div class="data-value">${env.interactive_elements ? env.interactive_elements.length : 0} elements</div>
                </div>
            `;
            
            dataContent.innerHTML = html;
            const envStatusElement = document.getElementById('env-status');
            if (envStatusElement) {
                envStatusElement.textContent = 'Environment loaded and visualized';
            }
        }
        
        // Control functions
        function forceHideLoading() {
            console.log('üö´ Force hiding loading screen...');
            
            // Find ALL elements that might be loading screens
            const loadingElements = document.querySelectorAll('#loading, .loading, [class*="loading"]');
            console.log('Found loading elements:', loadingElements.length);
            
            loadingElements.forEach((el, index) => {
                console.log(`Element ${index}:`, el);
                el.classList.add('hidden');
                el.style.display = 'none';
                el.style.visibility = 'hidden';
                el.style.opacity = '0';
                el.style.zIndex = '-1';
            });
            
            // Also hide by ID specifically
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.remove(); // Actually remove it from DOM
                console.log('Removed loading element from DOM');
            }
            
            // Debug: Check what's visible on the page
            console.log('üîç Page visibility debug:');
            console.log('Body:', document.body);
            console.log('Container:', document.getElementById('container'));
            console.log('Info panel:', document.getElementById('info-panel'));
            console.log('Controls:', document.getElementById('controls'));
            console.log('Canvas elements:', document.querySelectorAll('canvas'));
            
            // Also generate demo environment if none exists
            if (!environmentData) {
                console.log('No environment data found, generating demo...');
                generateDemoEnvironment();
            }
        }
        
        function toggleLighting() {
            lightingEnabled = !lightingEnabled;
            lightObjects.forEach(light => {
                light.visible = lightingEnabled;
            });
        }
        
        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            // Visual feedback for physics toggle
            environmentObjects.forEach(obj => {
                if (obj.userData && obj.userData.type === 'interactive_element') {
                    obj.material.color.setHex(physicsEnabled ? 0xe94560 : 0x888888);
                }
            });
        }
        
        function resetCamera() {
            camera.position.set(30, 20, 30);
            camera.lookAt(0, 0, 0);
        }
        
        function exportEnvironment() {
            if (environmentData) {
                const dataStr = JSON.stringify(environmentData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'holodeck_environment.json';
                link.click();
                URL.revokeObjectURL(url);
            }
        }
        
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize the visualizer
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ DOM Content Loaded - Starting initialization...');
            console.log('üîç Checking if Three.js is available:', typeof THREE);
            console.log('üîç Container element exists:', !!document.getElementById('container'));
            
            try {
                initThreeJS();
                console.log('‚úÖ Three.js initialization completed');
            } catch (error) {
                console.error('‚ùå Three.js initialization failed:', error);
            }
            
            // Auto-generate demo environment on load
            setTimeout(() => {
                console.log('üéÆ Auto-generating demo environment...');
                generateDemoEnvironment();
            }, 1000);
            
            // Setup click interaction system
            setupClickInteraction();
        });
        
        // Enterprise Crew Management
        function getSelectedCrew() {
            const selectedCrew = [];
            const crewMembers = [
                { id: 'picard', name: 'Jean-Luc Picard', rank: 'Captain', specialty: 'Command' },
                { id: 'riker', name: 'William Riker', rank: 'Commander', specialty: 'First Officer' },
                { id: 'data', name: 'Data', rank: 'Lt. Commander', specialty: 'Operations' },
                { id: 'worf', name: 'Worf', rank: 'Lieutenant', specialty: 'Security' },
                { id: 'laforge', name: 'Geordi La Forge', rank: 'Lt. Commander', specialty: 'Engineering' },
                { id: 'troi', name: 'Deanna Troi', rank: 'Lt. Commander', specialty: 'Counselor' },
                { id: 'crusher', name: 'Beverly Crusher', rank: 'Commander', specialty: 'Medical' }
            ];
            
            crewMembers.forEach(crew => {
                const checkbox = document.getElementById(crew.id);
                if (checkbox && checkbox.checked) {
                    selectedCrew.push(crew);
                }
            });
            
            return selectedCrew;
        }
        
        function createEnterpriseCrewCharacters() {
            const selectedCrew = getSelectedCrew();
            const crewCharacters = [];
            
            selectedCrew.forEach((crew, index) => {
                const character = createEnterpriseCharacter(crew);
                
                // Position crew members in a formation
                const angle = (index / selectedCrew.length) * Math.PI * 2;
                const radius = 15;
                
                character.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                character.rotation.y = angle + Math.PI; // Face center
                
                scene.add(character);
                environmentObjects.push(character);
                crewCharacters.push(character);
                
                console.log(`üññ Added Enterprise crew member: ${crew.name}`);
            });
            
            return crewCharacters;
        }
        
        function createEnterpriseCharacter(crewData) {
            const character = new THREE.Group();
            character.userData = { 
                type: 'enterprise_crew', 
                data: crewData,
                description: `${crewData.rank} ${crewData.name} - ${crewData.specialty} specialist from the USS Enterprise NCC-1701-D`
            };
            
            // Use specialized colors for Starfleet uniforms
            const uniformColors = {
                'picard': 0xdc143c,     // Command red
                'riker': 0xdc143c,      // Command red
                'data': 0xffd700,       // Operations gold
                'worf': 0xdc143c,       // Command red (security)
                'laforge': 0xffd700,    // Operations gold
                'troi': 0x6495ed,       // Sciences blue
                'crusher': 0x6495ed     // Medical blue
            };
            
            const config = {
                skinColor: crewData.id === 'data' ? 0xf5deb3 : 0xfdbcb4, // Data has pale skin
                clothingColor: uniformColors[crewData.id] || 0xdc143c,
                hairColor: crewData.id === 'data' ? 0xffd700 : 0x8b4513,
                name: `${crewData.rank} ${crewData.name}`,
                scale: 1.1 // Slightly larger for main characters
            };
            
            const humanModel = createHumanCharacter(config);
            character.add(humanModel);
            
            return character;
        }
        
        // Scene Management System
        let currentScene = 'intro';
        const sceneData = {
            intro: {
                name: "First Contact",
                description: "The Enterprise crew encounters the alien world",
                environment_type: "AlienWorld",
                scene_description: "A first contact scenario on an alien planet with mysterious technology"
            },
            exploration: {
                name: "Exploration",
                description: "Exploring ancient alien ruins and technology",
                environment_type: "HistoricalSetting",
                scene_description: "Ancient alien ruins with advanced technology and mysterious artifacts"
            },
            discovery: {
                name: "Discovery", 
                description: "A major discovery that changes everything",
                environment_type: "SpaceEnvironment",
                scene_description: "A space station or orbital facility with critical discoveries"
            },
            conflict: {
                name: "Conflict",
                description: "Tensions rise and conflicts emerge",
                environment_type: "TrainingFacility",
                scene_description: "A tactical simulation or conflict resolution environment"
            },
            resolution: {
                name: "Resolution",
                description: "Peace and understanding are achieved",
                environment_type: "FantasyRealm",
                scene_description: "A peaceful diplomatic meeting place with natural beauty"
            }
        };
        
        function loadScene(sceneId) {
            if (!sceneData[sceneId]) return;
            
            currentScene = sceneId;
            const scene = sceneData[sceneId];
            
            // Update UI
            document.querySelectorAll('.scene-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            console.log(`üé¨ Loading scene: ${scene.name}`);
            
            // Generate new environment for this scene
            generateEnvironmentForScene(scene);
        }
        
        function generateEnvironmentForScene(sceneInfo) {
            console.log('üåç Generating environment for scene:', sceneInfo.name);
            
            // Create custom request for this scene
            const request = {
                id: "scene_request",
                method: "call_tool",
                params: {
                    name: "generate_environment",
                    arguments: {
                        scene_description: sceneInfo.scene_description,
                        environment_type: sceneInfo.environment_type.toLowerCase(),
                        safety_level: "standard",
                        tenant: "holodeck-story-visualizer",
                        user_id: "enterprise-crew",
                        request_id: `scene-${currentScene}-${Date.now()}`
                    }
                }
            };
            
            // Send request to generate new environment
            generateNewEnvironment(request);
        }
        
        // Click Interaction System
        let raycaster, mouse;
        
        function setupClickInteraction() {
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Add click event listener to canvas
            renderer.domElement.addEventListener('click', onCanvasClick, false);
            console.log('üñ±Ô∏è Click interaction system initialized');
        }
        
        function onCanvasClick(event) {
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Find intersected objects
            const intersects = raycaster.intersectObjects(environmentObjects, true);
            
            if (intersects.length > 0) {
                const clickedObject = findTopLevelObject(intersects[0].object);
                showObjectInformation(clickedObject);
            } else {
                hideObjectInformation();
            }
        }
        
        function findTopLevelObject(object) {
            // Find the top-level object that has userData
            let current = object;
            while (current.parent && current.parent !== scene) {
                if (current.userData && (current.userData.type || current.userData.data)) {
                    return current;
                }
                current = current.parent;
            }
            return current;
        }
        
        function showObjectInformation(object) {
            const infoPanel = document.getElementById('object-info');
            const title = document.getElementById('object-title');
            const details = document.getElementById('object-details');
            
            if (!object.userData || !object.userData.type) {
                hideObjectInformation();
                return;
            }
            
            const userData = object.userData;
            let titleText = 'Unknown Object';
            let detailsHTML = 'No information available';
            
            switch (userData.type) {
                case 'enterprise_crew':
                    const crew = userData.data;
                    titleText = `üññ ${crew.name}`;
                    detailsHTML = `
                        <div class="info-item"><span class="info-label">Rank:</span> ${crew.rank}</div>
                        <div class="info-item"><span class="info-label">Role:</span> ${crew.specialty}</div>
                        <div class="info-item"><span class="info-label">Ship:</span> USS Enterprise NCC-1701-D</div>
                        <div class="info-item"><span class="info-label">Status:</span> Active Duty</div>
                        <div class="info-item" style="margin-top: 10px;">${userData.description}</div>
                    `;
                    break;
                    
                case 'key_location':
                    const location = userData.data;
                    titleText = `üìç ${location.name}`;
                    detailsHTML = `
                        <div class="info-item"><span class="info-label">Type:</span> Key Location</div>
                        <div class="info-item"><span class="info-label">Safety:</span> ${location.safety_zone ? 'Safe Zone' : 'Caution Required'}</div>
                        <div class="info-item"><span class="info-label">Access:</span> ${location.interaction_type}</div>
                        <div class="info-item" style="margin-top: 10px;">${location.description}</div>
                    `;
                    break;
                    
                case 'interactive_element':
                    const element = userData.data;
                    titleText = `üéÆ ${element.name}`;
                    detailsHTML = `
                        <div class="info-item"><span class="info-label">Type:</span> Interactive Element</div>
                        <div class="info-item"><span class="info-label">Action:</span> ${element.interaction_type}</div>
                        <div class="info-item"><span class="info-label">Physics:</span> ${element.physics_enabled ? 'Enabled' : 'Disabled'}</div>
                        <div class="info-item"><span class="info-label">Safety:</span> ${element.safety_constraints ? element.safety_constraints.join(', ') : 'None'}</div>
                        <div class="info-item" style="margin-top: 10px;">${element.description}</div>
                    `;
                    break;
                    
                default:
                    titleText = '‚ùì Unknown Object';
                    detailsHTML = `
                        <div class="info-item"><span class="info-label">Type:</span> ${userData.type}</div>
                        <div class="info-item" style="margin-top: 10px;">Click on objects and characters to learn more about them.</div>
                    `;
            }
            
            title.textContent = titleText;
            details.innerHTML = detailsHTML;
            infoPanel.style.display = 'block';
            
            console.log('üìã Showing information for:', titleText);
        }
        
        function hideObjectInformation() {
            const infoPanel = document.getElementById('object-info');
            infoPanel.style.display = 'none';
        }
    </script>
    
    <!-- Enterprise Crew Selection Panel -->
    <div id="crew-selection">
        <h2>üöÄ Enterprise Crew</h2>
        <div class="crew-member">
            <input type="checkbox" id="picard" checked>
            <label for="picard">Jean-Luc Picard</label>
            <span class="crew-rank">Captain</span>
        </div>
        <div class="crew-member">
            <input type="checkbox" id="riker" checked>
            <label for="riker">William Riker</label>
            <span class="crew-rank">Commander</span>
        </div>
        <div class="crew-member">
            <input type="checkbox" id="data">
            <label for="data">Data</label>
            <span class="crew-rank">Lt. Commander</span>
        </div>
        <div class="crew-member">
            <input type="checkbox" id="worf">
            <label for="worf">Worf</label>
            <span class="crew-rank">Lieutenant</span>
        </div>
        <div class="crew-member">
            <input type="checkbox" id="laforge">
            <label for="laforge">Geordi La Forge</label>
            <span class="crew-rank">Lt. Commander</span>
        </div>
        <div class="crew-member">
            <input type="checkbox" id="troi">
            <label for="troi">Deanna Troi</label>
            <span class="crew-rank">Lt. Commander</span>
        </div>
        <div class="crew-member">
            <input type="checkbox" id="crusher">
            <label for="crusher">Beverly Crusher</label>
            <span class="crew-rank">Commander</span>
        </div>
    </div>
    
    <!-- Story Management Panel -->
    <div id="story-panel">
        <h2>üìñ Story Scenes</h2>
        <button class="scene-button active" onclick="loadScene('intro')">Scene 1: First Contact</button>
        <button class="scene-button" onclick="loadScene('exploration')">Scene 2: Exploration</button>
        <button class="scene-button" onclick="loadScene('discovery')">Scene 3: Discovery</button>
        <button class="scene-button" onclick="loadScene('conflict')">Scene 4: Conflict</button>
        <button class="scene-button" onclick="loadScene('resolution')">Scene 5: Resolution</button>
    </div>
    
    <!-- Object Information Panel -->
    <div id="object-info">
        <h3 id="object-title">Object Information</h3>
        <div id="object-details">
            Click on any object or character to see information
        </div>
    </div>
</body>
</html>